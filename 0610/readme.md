


- np.array끼리 산술 연산자, 관계 연산자 가능

    ex) arr2 > arr =>
                        array([[False,  True,  True],
  
                               [ True, False,  True]])


- 인덱싱

  * loc,iloc 없이 인덱싱 가능

    ex) arr[2], arr[0][2] = arr[0,2]

  * bool 인덱싱

  관계 연산자 사용시 bool타입으로 반환되는걸 인덱스로 사용하여 조건에 맞는 값 출력

  ex) arr[arr>3]

  ** zero가 아닌 인덱스를 배열 형태로 출력

  np.where(배열 != 0)

  np.nonzero(배열)

  * 팬시 인덱싱

    1. 정수 배열을 사용한 인덱싱

        ex) 배열1[배열2] : 배열2를 인덱스를 활용하여 위치에 맞는 값 추출

         
    2. 부울 마스크를 사용한 인덱싱

        변수 = 배열1 관계연산자 값
       
        ex) 배열1[변수]

  
    3. 정수 배열과 마스크의 결합

        ex) 배열1[배열2][변수]


  *** 배열[[원하는 행],[원하는 열]] => 원하는 요소만 출력

  => 배열 [원하는 행][:,원하는 열] : 행 전체로 받고 열을 원하는 인덱스 순서로 바꿀 수도 있다


  
- 슬라이싱
  
  배열의 부분집합

    ex) arr[:2,1:]


===========================================================================


  - View(뷰)

    원본 데이터를 복사하지 않고도 배열의 일부에 접근하거나 수정 가능

    메모리 효율성이 좋고 변경사항은 원본 배열에도 반영이 된다(반대도)

      => 원본 데이터를 변경할 순 있지만 배열 구조에 영향은 주지 않는다


    ** 생성법

      1. 슬라이싱

         배열의 일부를 슬라이싱 하여 뷰 생성

        ex) 배열[:2,:2] => 새로운 뷰 생성

            뷰의 값을 변경하면 원본의 값도 변경된다

          ** reshape(-1) => 1차원으로 변경

              뷰의 차원 변경시 원본 차원 변경x


      2. view() 메소드
   
         원본 배열의 데이터를 그대로 유지하면서 새로운 뷰 객체 생성

         데이터 타입을 변경할 수도 있다

         (ex) arr.view(dtype=np.float32) => 같은 데이터를 다른 타입으로 해석하는 새로운 뷰 생성


  ===========================================================================


 - 배열 전치

     1. arr.T

     2. np.transpose(arr)
  
 - 축 바꾸기

     1. np.swapaxes(arr,axis1,axis2)

        두 축만을 대상으로 서로 위치를 교환(행과 열 교환)

        ex) 2행 3열의 arr가 있으면 np.swapaxes(arr,0,1), (arr,1,0)도 동일

        => 3행 2열로 변환
        
     3. np.transpose(arr,axes)

        여러 축의 순서를 완전히 재배열할 수 있으며 swapaxes보다 더 일반적이고 유연
        
        ex) (1,2,3)인 arr가 있으면 (0,1,2)인 상태

        np.transpose(arr,(1,0,2))

        즉 1차원 자리에 있는 1과 2차원 자리에 있는 2를 바꾸라는 의미

    ===========================================================================


   - 기본 연산

     * 누적합, 곱

       arr.cumsum() / cumprod() => 행별이나 열별로 원한다면 axis =1 / axis =0 사용
       
     * 나머지 구하기

       np.mod(배열1,배열2)

       np.remainder(배열1, 배열2)
       
     * 역수

       np.reciprocal(배열)

     => 0은 역수가 불가능하므로 divide by zero에 관련된 Warning 메시지 표시
     
       
     * 승수

        np.power(배열, 원하는 제곱의 수)

       => 제곱의 수 대신 배열로도 가능


        ** 양수인 원소의 개수

           (배열>0).sum()
       
    ===========================================================================

    - 메서드
  
      any() : 하나 이상의 값이 True인지 검사

      all() : 모든 원소가 True인지 검사
    
     - np.where()
  
       배열내 특정 조건에 만족하는 원소의 인덱스 찾기

       np.where(조건식)

       ** 삼향식의 벡터화 버전

           np.where(조건식,True일 때 값, False일 때 값)

       - np.meshgrid
      
         두 개 이상의 1차원 배열을 입력받아서 각각의 배열을 기반으로 좌표 그리드 생성하는 함수

         ex) xs, ys = np.meshgrid(x,y)


       - 정렬 sort

         행렬이 2차원 이상일 경우, axis 축 값 설정을 통해 로우, 칼럼 방향으로 정렬
         
         np.sort(배열) : 복사본으로 반환

            -> 파이썬(sorted 사용) : 새 리스트 = sorted(원본리스트)
            


         배열.sort() : 원본 반영

            -> 파이썬 : 기존 리스트.sort()

         
        => 다차원 배열의 정렬은 sort 메서드에 넘긴 축에 따라 1차원 부분을 정렬

           ex) 배열.sort(0 or 1) : default = 0

        ** 기본 원본 행렬의 원소에 대한 인덱스를 필요로 할 때

           np.argsort(배열) : 정렬된 순서에 따른 인덱스 반환

       *** np.argmax(배열) / np.argmin(배열)

           배열의 최댓값의 인덱스/ 최솟값의 인덱스 반환
       
    ===========================================================================


       - np.unique(배열)
   
       배열의 고유한 원소 찾아 정렬된 형태로 반환

       - np.intersect1d(배열1,배열2)

       두 배열간 공통 원소를 찾아 정렬된 형태로 반환

       - np.union1d(배열1, 배열2)

       두 배열을 합쳐 모든 고유한 원소를 정렬하여 반환

       - np.in1d(배열1, 배열2)

       배열1에 각 원소가 배열2에 존재하는지 여부를 bool 배열로 반환

       - set 함수

       반복 가능한 객체에서 중복 제거 후 고유한 모든 원소를 포함하는 집합 생성


    ===========================================================================

   - 배열의 입출력
  
     * 입력
       
     * np.save / np.load는 바이너리 형식(.npy 파일로 저장)
    
       ex) np.save('파일명',배열)

    * np.savez : 여러개의 배열을 압축된 형식으로 저장
  
      ex) np.savez('파일명',a=arr,b=arr)

     * 읽기
    
       np.load('파일명')

       ex) arch = np.load('파일명')

       => arch['a'] / arch['b'] => 두 개의 배열을 압축했으므로 두 개 배열을 출력


   ===========================================================================
   
   - np.pad함수

     배열의 가장자리에 패딩을 추가하는 데 사용

     패딩이란 배열의 가장자리에 추가되는 값

     주로 이미지 처리나 신경망에서 입력 데이터의 크기를 조정할 때 사용

    ex) np.pad(array, pad_width = ~, mode = '~', constant_values = ~)

   
             array: 패딩을 추가할 배열
   
            pad_width: 패딩의 너비를 지정하는 튜플
   
           mode: 패딩 모드를 지정하는 문자열
   
                => "constant", "edge", "reflect", "symmetric" 등
   
           constant_values: mode가 "constant"인 경우, 패딩에 추가할 상수 값을 지정

   - np.diag 함수
  
     주어진 배열의 주 대각선 요소를 추출하거나, 주어진 배열을 주 대각선 요소로 채운 대각행렬을 생성

        ex) np.diag(array) => 대각선 요소를 추출하여 1차원 배열로 반환

             np.diag(array, k=1) => 매개변수 k를 이용, 양수일 경우 위로 이동

    - np.unravel_index 함수
  
      1차원 배열의 인덱스를 다차원 배열의 인덱스로 변환하는 데 유용

          ex) np.unravel_index(indices,shape)

          indices: 변환할 1차원 배열의 인덱스 /  스칼라 또는 배열 형태
          
          shape: 다차원 배열의 모양을 나타내는 튜플


   - tile 함수

     배열이나 리스트와 같은 반복 가능한 객체를 반복하여 배열을 생성하는 데 사용

     주어진 배열을 지정된 형태로 반복하여 새로운 배열을 만든다

     ex) np.tile(arr, (3, 1)) => arr를 행으로 3번 반복, 열로 1번 반복

     
