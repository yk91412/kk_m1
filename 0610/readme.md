


- np.array끼리 산술 연산자, 관계 연산자 가능

    ex) arr2 > arr =>
                        array([[False,  True,  True],
  
                               [ True, False,  True]])


- 인덱싱

  * loc,iloc 없이 인덱싱 가능

    ex) arr[2], arr[0][2] = arr[0,2]

  * bool 인덱싱

  관계 연산자 사용시 bool타입으로 반환되는걸 인덱스로 사용하여 조건에 맞는 값 출력

  ex) arr[arr>3]

  ** zero가 아닌 인덱스를 배열 형태로 출력

  np.where(배열 != 0)

  np.nonzero(배열)

  * 팬시 인덱싱

    1. 정수 배열을 사용한 인덱싱

        ex) 배열1[배열2] : 배열2를 인덱스를 활용하여 위치에 맞는 값 추출

         
    2. 부울 마스크를 사용한 인덱싱

        변수 = 배열1 관계연산자 값
       
        ex) 배열1[변수]

  
    3. 정수 배열과 마스크의 결합

        ex) 배열1[배열2][변수]


  *** 배열[[원하는 행],[원하는 열]] => 원하는 요소만 출력

  => 배열 [원하는 행][:,원하는 열] : 행 전체로 받고 열을 원하는 인덱스 순서로 바꿀 수도 있다


  
- 슬라이싱
  
  배열의 부분집합

    ex) arr[:2,1:]


===========================================================================


  - View(뷰)

    원본 데이터를 복사하지 않고도 배열의 일부에 접근하거나 수정 가능

    메모리 효율성이 좋고 변경사항은 원본 배열에도 반영이 된다(반대도)

      => 원본 데이터를 변경할 순 있지만 배열 구조에 영향은 주지 않는다


    ** 생성법

      1. 슬라이싱

         배열의 일부를 슬라이싱 하여 뷰 생성

        ex) 배열[:2,:2] => 새로운 뷰 생성

            뷰의 값을 변경하면 원본의 값도 변경된다

          ** reshape(-1) => 1차원으로 변경

              뷰의 차원 변경시 원본 차원 변경x


      2. view() 메소드
   
         원본 배열의 데이터를 그대로 유지하면서 새로운 뷰 객체 생성

         데이터 타입을 변경할 수도 있다

         (ex) arr.view(dtype=np.float32) => 같은 데이터를 다른 타입으로 해석하는 새로운 뷰 생성


  ===========================================================================


 - 배열 전치

     1. arr.T

     2. np.transpose(arr)
  
 - 축 바꾸기

     1. np.swapaxes(arr,axis1,axis2)

        두 축만을 대상으로 서로 위치를 교환(행과 열 교환)

        ex) 2행 3열의 arr가 있으면 np.swapaxes(arr,0,1), (arr,1,0)도 동일

        => 3행 2열로 변환
        
     3. np.transpose(arr,axes)

        여러 축의 순서를 완전히 재배열할 수 있으며 swapaxes보다 더 일반적이고 유연
        
        ex) (1,2,3)인 arr가 있으면 (0,1,2)인 상태

        np.transpose(arr,(1,0,2))

        즉 1차원 자리에 있는 1과 2차원 자리에 있는 2를 바꾸라는 의미

        
